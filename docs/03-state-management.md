# 3. إدارة الحالة (State Management)

إدارة الحالة هي الطريقة التي يتم بها تخزين البيانات وتحديثها ومشاركتها عبر مكونات التطبيق.

## النهج الحالي (بدون خادم)

في هذا المشروع، نعتمد على آليات React المدمجة وهوك مخصص.
1.  **حالة مركزية** في المكون الرئيسي `App.tsx`.
2.  **تمرير الخصائص (Props Drilling)** لمشاركة الحالة والوظائف مع المكونات الفرعية.
3.  **هوك `useLocalStorage`** للحفاظ على الحالة بين جلسات المتصفح.

---

## 1. الحالة المركزية في `App.tsx`

المكون `App.tsx` يعمل كـ "مصدر الحقيقة الوحيد" (Single Source of Truth) لمعظم بيانات التطبيق الهامة.

```typescript
// داخل App.tsx
const [currentUser, setCurrentUser] = useLocalStorage<User | null>('currentUser', null);
const [points, setPoints] = useLocalStorage<number>(userDataKey('points'), 0);
// ... باقي الحالات
```
- **لماذا؟**: تجميع الحالة في مكان واحد يسهل تتبع البيانات وفهم تدفقها.

---

## 2. تمرير الخصائص (Props Drilling)

بما أن الحالة موجودة في `App.tsx`، فإن الطريقة الوحيدة لوصول المكونات الفرعية إليها هي عن طريق تمريرها كـ `props`.

- **مثال**: مكون `Header.tsx` يحتاج إلى عرض عدد النقاط. في `App.tsx`، يتم تمريرها بهذا الشكل:
  ```jsx
  // في App.tsx
  <Header 
      points={points} 
      // ... props أخرى
  />
  ```

---

## 3. الهوك المخصص `useLocalStorage`

هذا الهوك هو ما يجعل التطبيق "يتذكر" تقدم المستخدم بين الجلسات بدون الحاجة إلى خادم. عند الانتقال إلى بنية حقيقية، سيتم استبدال استخدامه.

---

## 4. إدارة الحالة في تطبيق متصل بخادم (الخطوة التالية)

عند ربط التطبيق بواجهة خلفية (Backend)، تتغير طبيعة إدارة الحالة بشكل كبير. البيانات لم تعد مخزنة محليًا فقط، بل أصبحت "حالة خادم" (Server State) يجب جلبها وتحديثها ومزامنتها.

### تحديات حالة الخادم:
- **الجلب (Fetching)**: كيف ومتى نطلب البيانات من الخادم؟
- **التخزين المؤقت (Caching)**: كيف نخزن البيانات محليًا لتجنب الطلبات المتكررة وتقليل التحميل؟
- **المزامنة (Synchronization)**: كيف نضمن أن البيانات المعروضة للمستخدم هي أحدث نسخة من الخادم؟
- **التعامل مع الأخطاء وحالات التحميل**.

### الحلول المقترحة:
بدلاً من استخدام `useState` و `useEffect` يدويًا لكل طلب API، من الأفضل استخدام مكتبات متخصصة لإدارة حالة الخادم. أشهرها:

- **React Query (الآن TanStack Query)**: هي الخيار الأكثر شيوعًا وقوة. توفر Hooks جاهزة (`useQuery`, `useMutation`) تتعامل تلقائيًا مع الجلب، التخزين المؤقت، التحديث في الخلفية، إعادة المحاولة عند الفشل، والمزيد. هذا يقلل بشكل كبير من كمية الكود الذي تحتاجه.
- **SWR**: مكتبة مشابهة من Vercel، تركز على البساطة والسرعة.
- **Redux Toolkit (مع RTK Query)**: إذا كان تطبيقك يحتاج إلى إدارة حالة عميل معقدة (Client State) بالإضافة إلى حالة الخادم، فإن Redux Toolkit مع RTK Query يوفر حلاً متكاملاً.

**الخلاصة**: عند بناء الواجهة الخلفية، الخطوة التالية في الواجهة الأمامية هي دمج مكتبة مثل **React Query** لإدارة التفاعل مع الـ API بكفاءة. هذا سيجعل الكود أنظف وأكثر قوة وقابلية للتوسع.