# 7. نظام الدردشة: من محاكاة إلى نظام حقيقي

## النهج الحالي: محاكاة باستخدام `localStorage`

يحتوي التطبيق على نظام دردشة يسمح للمستخدمين بإنشاء غرف والانضمام إليها وإرسال الرسائل. من المهم جدًا فهم أن هذا النظام هو **محاكاة** تعمل بالكامل داخل `localStorage` في متصفح واحد.

- **المكونات المسؤولة**: `Chat.tsx`, `CreateRoomModal.tsx`, `RoomView.tsx`.
- **بنية البيانات**: يتم تخزين الغرف (`chatRooms`) والرسائل (`chatMessages`) في `localStorage`.
- **آلية العمل**: كل العمليات (إنشاء، انضمام، إرسال رسالة) تقوم بتعديل البيانات في `localStorage` مباشرة.

### القيود
- **محلية بالكامل**: كل هذا يحدث في متصفح واحد. مستخدم على جهاز آخر لن يرى نفس الغرف أو الرسائل.
- **لا يوجد تحديث حي**: لا يوجد اتصال في الوقت الفعلي بين المستخدمين.

---

## الخطوة التالية: بناء نظام دردشة حقيقي عبر الإنترنت

لجعل الدردشة تعمل بين مستخدمين مختلفين على أجهزة مختلفة، نحتاج إلى استخدام تقنية تسمح بالاتصال ثنائي الاتجاه في الوقت الفعلي بين العميل والخادم. الحل الأمثل لهذا هو **WebSockets**.

### ما هي WebSockets؟
- هي تقنية تفتح قناة اتصال مستمرة بين العميل والخادم.
- بمجرد تأسيس الاتصال، يمكن لكل من العميل والخادم إرسال البيانات إلى بعضهما البعض في أي وقت دون الحاجة إلى إرسال طلب HTTP جديد لكل رسالة.
- هذا يجعلها مثالية للتطبيقات التي تتطلب تحديثات حية مثل الدردشة، الألعاب عبر الإنترنت، وإشعارات الوقت الفعلي.

### مكتبة مقترحة: Socket.IO
- **Socket.IO** هي مكتبة JavaScript تجعل العمل مع WebSockets أسهل بكثير.
- توفر ميزات إضافية مثل إعادة الاتصال التلقائي، والبث إلى غرف محددة، وتعمل كبديل في حال لم تكن WebSockets مدعومة.

### كيف سيعمل النظام الجديد؟

1.  **الخادم (Backend)**:
    - سيقوم الخادم بإنشاء `Socket.IO server`.
    - سيستمع الخادم إلى أحداث (events) قادمة من العملاء.

2.  **العميل (Frontend)**:
    - سيستخدم `Socket.IO client` للاتصال بالخادم.
    - سيرسل (emits) أحداثًا إلى الخادم عند وقوع إجراءات معينة (مثل إرسال رسالة).
    - سيستمع (listens) إلى الأحداث القادمة من الخادم لعرض البيانات الجديدة (مثل استلام رسالة).

### مثال على تدفق الأحداث (Event Flow):

- **الاتصال**:
  - العميل يتصل بالخادم: `socket.connect()`.
  - الخادم يستقبل الاتصال: `io.on('connection', (socket) => { ... });`

- **الانضمام إلى غرفة**:
  - العميل يرسل حدث `join_room` مع `roomId`: `socket.emit('join_room', { roomId: 'R1234' });`
  - الخادم يستمع للحدث ويضم العميل إلى الغرفة المحددة: `socket.on('join_room', ({ roomId }) => { socket.join(roomId); });`

- **إرسال رسالة**:
  - العميل يرسل حدث `send_message` مع تفاصيل الرسالة: `socket.emit('send_message', { roomId: 'R1234', text: 'Hello!' });`
  - الخادم يستمع للحدث، يحفظ الرسالة في قاعدة البيانات، ثم يبث الرسالة الجديدة **إلى كل العملاء في نفس الغرفة**: `io.to(roomId).emit('receive_message', newMessage);`

- **استلام رسالة**:
  - جميع العملاء في الغرفة يستمعون لحدث `receive_message`: `socket.on('receive_message', (newMessage) => { ... });`
  - عند استلام الحدث، يقومون بتحديث واجهتهم لعرض الرسالة الجديدة.

هذا النموذج يضمن أن جميع المستخدمين في غرفة الدردشة يتلقون الرسائل الجديدة على الفور، مما يخلق تجربة دردشة حقيقية في الوقت الفعلي. لمزيد من التفاصيل التقنية، راجع **[دليل تكامل الواجهة الخلفية](./09-backend-integration.md)**.